"""Helper functions for running different stages of alignment"""

# system deps
import argparse
import os
import sys
import json
from typing import List

# external deps
import typer

# us
import _cmd
from _cfg import cfg

app = typer.Typer()

@app.command()
def construct(det_name : str) :
    """
    Construct a detector LCDD from the compact.xml

    The directory corresponding to DET_NAME is assumed to already
    exist withing <hps-java>/detector-data/detectors.
    """
    detector_dir = os.path.join(cfg.cfg().javadir, 'detector-data/detectors', det_name)
    # construct LCDD from compact
    _cmd.run(['java'] + cfg.cfg().javaopts + [
        '-cp', cfg.cfg().jarfile,
        'org.hps.detector.DetectorConverter',
        '-f', 'lcdd',
        '-i', f'{detector_dir}/compact.xml',
        '-o', f'{detector_dir}/{det_name}.lcdd'
      ], cwd = os.path.join(cfg.cfg().javadir,'detector-data'))

    # write detector name
    with open(f'{detector_dir}/detector.properties','w') as f :
        f.write(f'name: {det_name}\n')

    # rebuild jar to include this new detector
    _cmd.run(['mvn'] + cfg.cfg().mvnopts, cwd=os.path.join(cfg.cfg().javadir,'detector-data'))
    _cmd.run(['mvn'] + cfg.cfg().mvnopts, cwd=os.path.join(cfg.cfg().javadir,'distribution'))
    
@app.command()
def tracking(det_name : str, run : int, input_file : str, 
    method : str = typer.Option('kf',help='type of tracking to do (kf or st)'),
    out_prefix : str = typer.Option(None,help='prefix to put onto output files'), 
    new_det : bool = typer.Option(False,help='this is a new detector and so we should construct it first'),
    ) :
    """
    Run tracking in the input detector.

    The detector LCDD is assumed to already be constructed.
    """

    if new_det :
        construct(det_name)

    # allow output file prefix to define an output directory
    #   and create it if it doesn't exist yet
    import os
    d = os.path.dirname(out_prefix)
    if d != '' :
        os.makedirs(d, exist_ok=True)

    steering = None
    if method == 'kf' :
        steering = cfg.cfg().kf_steer
    elif method == 'st' :
        steering = cfg.cfg().st_steer
    else :
        raise ValueError('Unknown tracking method "%s", choices are "kf" or "st"' % method)

    # run tracking over the input detector
    _cmd.run(['java'] + cfg.cfg().javaopts + [
      '-DdisableSvtAlignmentConstants',
      '-jar', cfg.cfg().jarfile,
      '-R', str(run), 
      '-d', det_name,
      f'-DoutputFile={out_prefix}',
      steering,
      '-i', input_file
      ])

@app.command()
def millepede(
        input_file : List[str],
        to_float : List[str],
        survey_constraints : bool = typer.Option(False,
            help='apply constraints from survey'),
        beamspot_constraints : bool = typer.Option(False,
            help='apply beam spot constraints'),
        minimization : str = typer.Option(cfg.cfg().pede_minimization,
            help='file holding the minimization settings for pede'),
        constraint_file : str = typer.Option(None,
            help='optional external constraint file for pede')
        ) :
    """
    Run the pede minimizer over the bin files generated by tracking
    """

    # get default parameters depending on beamspot and year

    # update parameters from previous fit

    # define which parameters are floating

    # determine MP minimization settings
    with open(minimization) as minfile :
        minimization = minfile.readlines()

    # build steering file for pede
    pede_steering_file = os.path.join(out_dir,prefix,'steer.txt')
    with open(pede_steering_file,'w') as psf :
        # write out input mille binary files
        psf.write('CFiles\n')
        for ipf in input_file :
            f.write(ipf+'\n')

        # external contraint file
        if contraint_file is not None :
            f.write('\n')
            f.write('!Constraint file\n')
            f.write(constraint_file+'\n')

        # parameters that can float
        f.write('\nParameter\n')
        for p in parameters :
            f.write(p.pede_format() + '\n')

        # survey constraints
        if survey_constraints :
            f.write(buildSteering.getSurveyMeasurements(paramMap))
            f.write("\n\n")
        
        #Apply beamspotConstraint (This I think is not correct)
        if beamspot_constraints:
            #f.write(buildSteering.getBeamspotConstraints(paramMap))
            f.write(buildSteering.getBeamspotConstraintsFloatingOnly(pars))
            f.write("\n\n")
        
        f.write("\n\n")
        f.write(minimization)

    # run pede
    for ext in ['res','eve','log','his'] :
        _cmd.run(['rm','-f', f'millepede.{ext}'], 
                cwd=cfg.cfg().scratch)
    pede_cmd = [cfg.cfg().pede, pede_steering_file]
    if subito :
        pede_cmd.append('-s')
    _cmd.run(pede_cmd, cwd=cfg.cfg().scratch)

    # move output to destination directory
    for ext in ['res','eve','log','his'] :
        f=os.path.join(cfg.cfg().scratch,f'millepede.{ext}')
        if os.path.isfile(f) :
            shutil.copy2(f,os.path.join(out_dir,prefix,f))

    return

@app.command()
def config() :
    """
    Print the deduced/parsed config for debugging
    """

    print(cfg.cfg())
    return

@app.callback()
def main(config : str =  typer.Option(None,help='JSON config file')):
    """
    run alignment sub commands
    """

    conf_kw = dict()
    if config is not None :
        with open(config) as f :
            conf_kw = json.load(f)

    cfg.cfg(**conf_kw)
